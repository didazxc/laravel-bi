<?php

namespace Zxc\Thrift\Hbase;

/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


interface THBaseServiceIf {
  /**
   * Test for the existence of columns in the table, as specified in the TGet.
   * 
   * @return true if the specified TGet matches one or more keys, false if not
   * 
   * @param string $table the table to check on
   * 
   * @param TGet $tget the TGet to check for
   * 
   * @return bool
   * @throws TIOError
   */
  public function exists($table, TGet $tget);
  /**
   * Method for getting data from a row.
   * 
   * If the row cannot be found an empty Result is returned.
   * This can be checked by the empty field of the TResult
   * 
   * @return the result
   * 
   * @param string $table the table to get from
   * 
   * @param TGet $tget the TGet to fetch
   * 
   * @return TResult if no Result is found, row and columnValues will not be set.
   * 
   * @throws TIOError
   */
  public function get($table, TGet $tget);
  /**
   * Method for getting multiple rows.
   * 
   * If a row cannot be found there will be a null
   * value in the result list for that TGet at the
   * same position.
   * 
   * So the Results are in the same order as the TGets.
   * 
   * @param string $table the table to get from
   * 
   * @param TGet[] $tgets a list of TGets to fetch, the Result list
   * will have the Results at corresponding positions
   * or null if there was an error
   * 
   * @return TResult[]
   * @throws TIOError
   */
  public function getMultiple($table, array $tgets);
  /**
   * Commit a TPut to a table.
   * 
   * @param string $table the table to put data in
   * 
   * @param TPut $tput the TPut to put
   * 
   * @throws TIOError
   */
  public function put($table, TPut $tput);
  /**
   * Atomically checks if a row/family/qualifier value matches the expected
   * value. If it does, it adds the TPut.
   * 
   * @return true if the new put was executed, false otherwise
   * 
   * @param string $table to check in and put to
   * 
   * @param string $row row to check
   * 
   * @param string $family column family to check
   * 
   * @param string $qualifier column qualifier to check
   * 
   * @param string $value the expected value, if not provided the
   * check is for the non-existence of the
   * column in question
   * 
   * @param TPut $tput the TPut to put if the check succeeds
   * 
   * @return bool
   * @throws TIOError
   */
  public function checkAndPut($table, $row, $family, $qualifier, $value, TPut $tput);
  /**
   * Commit a List of Puts to the table.
   * 
   * @param string $table the table to put data in
   * 
   * @param TPut[] $tputs a list of TPuts to commit
   * 
   * @throws TIOError
   */
  public function putMultiple($table, array $tputs);
  /**
   * Deletes as specified by the TDelete.
   * 
   * Note: "delete" is a reserved keyword and cannot be used in Thrift
   * thus the inconsistent naming scheme from the other functions.
   * 
   * @param string $table the table to delete from
   * 
   * @param TDelete $tdelete the TDelete to delete
   * 
   * @throws TIOError
   */
  public function deleteSingle($table, TDelete $tdelete);
  /**
   * Bulk commit a List of TDeletes to the table.
   * 
   * Throws a TIOError if any of the deletes fail.
   * 
   * Always returns an empty list for backwards compatibility.
   * 
   * @param string $table the table to delete from
   * 
   * @param TDelete[] $tdeletes list of TDeletes to delete
   * 
   * @return TDelete[]
   * @throws TIOError
   */
  public function deleteMultiple($table, array $tdeletes);
  /**
   * Atomically checks if a row/family/qualifier value matches the expected
   * value. If it does, it adds the delete.
   * 
   * @return true if the new delete was executed, false otherwise
   * 
   * @param string $table to check in and delete from
   * 
   * @param string $row row to check
   * 
   * @param string $family column family to check
   * 
   * @param string $qualifier column qualifier to check
   * 
   * @param string $value the expected value, if not provided the
   * check is for the non-existence of the
   * column in question
   * 
   * @param TDelete $tdelete the TDelete to execute if the check succeeds
   * 
   * @return bool
   * @throws TIOError
   */
  public function checkAndDelete($table, $row, $family, $qualifier, $value, TDelete $tdelete);
  /**
   * @param string $table the table to increment the value on
   * 
   * @param TIncrement $tincrement the TIncrement to increment
   * 
   * @return TResult if no Result is found, row and columnValues will not be set.
   * 
   * @throws TIOError
   */
  public function increment($table, TIncrement $tincrement);
  /**
   * @param string $table the table to append the value on
   * 
   * @param TAppend $tappend the TAppend to append
   * 
   * @return TResult if no Result is found, row and columnValues will not be set.
   * 
   * @throws TIOError
   */
  public function append($table, TAppend $tappend);
  /**
   * Get a Scanner for the provided TScan object.
   * 
   * @return Scanner Id to be used with other scanner procedures
   * 
   * @param string $table the table to get the Scanner for
   * 
   * @param TScan $tscan the scan object to get a Scanner for
   * 
   * @return int
   * @throws TIOError
   */
  public function openScanner($table, TScan $tscan);
  /**
   * Grabs multiple rows from a Scanner.
   * 
   * @return Between zero and numRows TResults
   * 
   * @param int $scannerId the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
   * 
   * @param int $numRows number of rows to return
   * 
   * @return TResult[]
   * @throws TIOError
   * @throws TIllegalArgument if the scannerId is invalid
   * 
   */
  public function getScannerRows($scannerId, $numRows);
  /**
   * Closes the scanner. Should be called to free server side resources timely.
   * Typically close once the scanner is not needed anymore, i.e. after looping
   * over it to get all the required rows.
   * 
   * @param int $scannerId the Id of the Scanner to close *
   * 
   * @throws TIOError
   * @throws TIllegalArgument if the scannerId is invalid
   * 
   */
  public function closeScanner($scannerId);
  /**
   * mutateRow performs multiple mutations atomically on a single row.
   * 
   * @param string $table table to apply the mutations
   * 
   * @param TRowMutations $trowMutations mutations to apply
   * 
   * @throws TIOError
   */
  public function mutateRow($table, TRowMutations $trowMutations);
  /**
   * Get results for the provided TScan object.
   * This helper function opens a scanner, get the results and close the scanner.
   * 
   * @return between zero and numRows TResults
   * 
   * @param string $table the table to get the Scanner for
   * 
   * @param TScan $tscan the scan object to get a Scanner for
   * 
   * @param int $numRows number of rows to return
   * 
   * @return TResult[]
   * @throws TIOError
   */
  public function getScannerResults($table, TScan $tscan, $numRows);
  /**
   * Given a table and a row get the location of the region that
   * would contain the given row key.
   * 
   * reload = true means the cache will be cleared and the location
   * will be fetched from meta.
   * 
   * @param string $table
   * @param string $row
   * @param bool $reload
   * @return THRegionLocation
   * @throws TIOError
   */
  public function getRegionLocation($table, $row, $reload);
  /**
   * Get all of the region locations for a given table.
   * 
   * 
   * @param string $table
   * @return THRegionLocation[]
   * @throws TIOError
   */
  public function getAllRegionLocations($table);
}


class THBaseServiceClient implements THBaseServiceIf {
  protected $input_ = null;
  protected $output_ = null;

  protected $seqid_ = 0;

  public function __construct($input, $output=null) {
    $this->input_ = $input;
    $this->output_ = $output ? $output : $input;
  }

  public function exists($table, TGet $tget)
  {
    $this->send_exists($table, $tget);
    return $this->recv_exists();
  }

  public function send_exists($table, TGet $tget)
  {
    $args = new THBaseService_exists_args();
    $args->table = $table;
    $args->tget = $tget;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'exists', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('exists', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_exists()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_exists_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_exists_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("exists failed: unknown result");
  }

  public function get($table, TGet $tget)
  {
    $this->send_get($table, $tget);
    return $this->recv_get();
  }

  public function send_get($table, TGet $tget)
  {
    $args = new THBaseService_get_args();
    $args->table = $table;
    $args->tget = $tget;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_get_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_get_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("get failed: unknown result");
  }

  public function getMultiple($table, array $tgets)
  {
    $this->send_getMultiple($table, $tgets);
    return $this->recv_getMultiple();
  }

  public function send_getMultiple($table, array $tgets)
  {
    $args = new THBaseService_getMultiple_args();
    $args->table = $table;
    $args->tgets = $tgets;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getMultiple', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getMultiple', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getMultiple()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_getMultiple_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_getMultiple_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getMultiple failed: unknown result");
  }

  public function put($table, TPut $tput)
  {
    $this->send_put($table, $tput);
    $this->recv_put();
  }

  public function send_put($table, TPut $tput)
  {
    $args = new THBaseService_put_args();
    $args->table = $table;
    $args->tput = $tput;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'put', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('put', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_put()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_put_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_put_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function checkAndPut($table, $row, $family, $qualifier, $value, TPut $tput)
  {
    $this->send_checkAndPut($table, $row, $family, $qualifier, $value, $tput);
    return $this->recv_checkAndPut();
  }

  public function send_checkAndPut($table, $row, $family, $qualifier, $value, TPut $tput)
  {
    $args = new THBaseService_checkAndPut_args();
    $args->table = $table;
    $args->row = $row;
    $args->family = $family;
    $args->qualifier = $qualifier;
    $args->value = $value;
    $args->tput = $tput;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'checkAndPut', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('checkAndPut', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_checkAndPut()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_checkAndPut_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_checkAndPut_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("checkAndPut failed: unknown result");
  }

  public function putMultiple($table, array $tputs)
  {
    $this->send_putMultiple($table, $tputs);
    $this->recv_putMultiple();
  }

  public function send_putMultiple($table, array $tputs)
  {
    $args = new THBaseService_putMultiple_args();
    $args->table = $table;
    $args->tputs = $tputs;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'putMultiple', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('putMultiple', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_putMultiple()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_putMultiple_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_putMultiple_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function deleteSingle($table, TDelete $tdelete)
  {
    $this->send_deleteSingle($table, $tdelete);
    $this->recv_deleteSingle();
  }

  public function send_deleteSingle($table, TDelete $tdelete)
  {
    $args = new THBaseService_deleteSingle_args();
    $args->table = $table;
    $args->tdelete = $tdelete;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteSingle', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteSingle', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteSingle()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_deleteSingle_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_deleteSingle_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function deleteMultiple($table, array $tdeletes)
  {
    $this->send_deleteMultiple($table, $tdeletes);
    return $this->recv_deleteMultiple();
  }

  public function send_deleteMultiple($table, array $tdeletes)
  {
    $args = new THBaseService_deleteMultiple_args();
    $args->table = $table;
    $args->tdeletes = $tdeletes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteMultiple', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteMultiple', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteMultiple()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_deleteMultiple_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_deleteMultiple_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("deleteMultiple failed: unknown result");
  }

  public function checkAndDelete($table, $row, $family, $qualifier, $value, TDelete $tdelete)
  {
    $this->send_checkAndDelete($table, $row, $family, $qualifier, $value, $tdelete);
    return $this->recv_checkAndDelete();
  }

  public function send_checkAndDelete($table, $row, $family, $qualifier, $value, TDelete $tdelete)
  {
    $args = new THBaseService_checkAndDelete_args();
    $args->table = $table;
    $args->row = $row;
    $args->family = $family;
    $args->qualifier = $qualifier;
    $args->value = $value;
    $args->tdelete = $tdelete;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'checkAndDelete', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('checkAndDelete', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_checkAndDelete()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_checkAndDelete_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_checkAndDelete_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("checkAndDelete failed: unknown result");
  }

  public function increment($table, TIncrement $tincrement)
  {
    $this->send_increment($table, $tincrement);
    return $this->recv_increment();
  }

  public function send_increment($table, TIncrement $tincrement)
  {
    $args = new THBaseService_increment_args();
    $args->table = $table;
    $args->tincrement = $tincrement;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'increment', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('increment', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_increment()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_increment_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_increment_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("increment failed: unknown result");
  }

  public function append($table, TAppend $tappend)
  {
    $this->send_append($table, $tappend);
    return $this->recv_append();
  }

  public function send_append($table, TAppend $tappend)
  {
    $args = new THBaseService_append_args();
    $args->table = $table;
    $args->tappend = $tappend;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'append', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('append', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_append()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_append_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_append_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("append failed: unknown result");
  }

  public function openScanner($table, TScan $tscan)
  {
    $this->send_openScanner($table, $tscan);
    return $this->recv_openScanner();
  }

  public function send_openScanner($table, TScan $tscan)
  {
    $args = new THBaseService_openScanner_args();
    $args->table = $table;
    $args->tscan = $tscan;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'openScanner', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('openScanner', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_openScanner()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_openScanner_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_openScanner_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("openScanner failed: unknown result");
  }

  public function getScannerRows($scannerId, $numRows)
  {
    $this->send_getScannerRows($scannerId, $numRows);
    return $this->recv_getScannerRows();
  }

  public function send_getScannerRows($scannerId, $numRows)
  {
    $args = new THBaseService_getScannerRows_args();
    $args->scannerId = $scannerId;
    $args->numRows = $numRows;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getScannerRows', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getScannerRows', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getScannerRows()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_getScannerRows_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_getScannerRows_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    throw new Exception("getScannerRows failed: unknown result");
  }

  public function closeScanner($scannerId)
  {
    $this->send_closeScanner($scannerId);
    $this->recv_closeScanner();
  }

  public function send_closeScanner($scannerId)
  {
    $args = new THBaseService_closeScanner_args();
    $args->scannerId = $scannerId;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'closeScanner', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('closeScanner', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_closeScanner()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_closeScanner_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_closeScanner_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    return;
  }

  public function mutateRow($table, TRowMutations $trowMutations)
  {
    $this->send_mutateRow($table, $trowMutations);
    $this->recv_mutateRow();
  }

  public function send_mutateRow($table, TRowMutations $trowMutations)
  {
    $args = new THBaseService_mutateRow_args();
    $args->table = $table;
    $args->trowMutations = $trowMutations;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'mutateRow', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('mutateRow', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_mutateRow()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_mutateRow_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_mutateRow_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function getScannerResults($table, TScan $tscan, $numRows)
  {
    $this->send_getScannerResults($table, $tscan, $numRows);
    return $this->recv_getScannerResults();
  }

  public function send_getScannerResults($table, TScan $tscan, $numRows)
  {
    $args = new THBaseService_getScannerResults_args();
    $args->table = $table;
    $args->tscan = $tscan;
    $args->numRows = $numRows;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getScannerResults', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getScannerResults', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getScannerResults()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_getScannerResults_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_getScannerResults_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getScannerResults failed: unknown result");
  }

  public function getRegionLocation($table, $row, $reload)
  {
    $this->send_getRegionLocation($table, $row, $reload);
    return $this->recv_getRegionLocation();
  }

  public function send_getRegionLocation($table, $row, $reload)
  {
    $args = new THBaseService_getRegionLocation_args();
    $args->table = $table;
    $args->row = $row;
    $args->reload = $reload;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRegionLocation', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRegionLocation', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRegionLocation()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_getRegionLocation_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_getRegionLocation_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getRegionLocation failed: unknown result");
  }

  public function getAllRegionLocations($table)
  {
    $this->send_getAllRegionLocations($table);
    return $this->recv_getAllRegionLocations();
  }

  public function send_getAllRegionLocations($table)
  {
    $args = new THBaseService_getAllRegionLocations_args();
    $args->table = $table;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getAllRegionLocations', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getAllRegionLocations', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getAllRegionLocations()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\THBaseService_getAllRegionLocations_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new THBaseService_getAllRegionLocations_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getAllRegionLocations failed: unknown result");
  }

}


// HELPER FUNCTIONS AND STRUCTURES

class THBaseService_exists_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'tget',
      'isRequired' => true,
      'type' => TType::STRUCT,
      'class' => '\TGet',
      ),
    );

  /**
   * the table to check on
   * 
   * @var string
   */
  public $table = null;
  /**
   * the TGet to check for
   * 
   * @var TGet
   */
  public $tget = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['tget'])) {
        $this->tget = $vals['tget'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_exists_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->tget = new TGet();
            $xfer += $this->tget->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_exists_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tget !== null) {
      if (!is_object($this->tget)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tget', TType::STRUCT, 2);
      $xfer += $this->tget->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_exists_result {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_exists_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_exists_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_get_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'tget',
      'isRequired' => true,
      'type' => TType::STRUCT,
      'class' => '\TGet',
      ),
    );

  /**
   * the table to get from
   * 
   * @var string
   */
  public $table = null;
  /**
   * the TGet to fetch
   * 
   * @var TGet
   */
  public $tget = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['tget'])) {
        $this->tget = $vals['tget'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_get_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->tget = new TGet();
            $xfer += $this->tget->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_get_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tget !== null) {
      if (!is_object($this->tget)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tget', TType::STRUCT, 2);
      $xfer += $this->tget->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_get_result {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TResult',
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var TResult
   */
  public $success = null;
  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_get_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new TResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_get_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_getMultiple_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'tgets',
      'isRequired' => true,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\TGet',
        ),
      ),
    );

  /**
   * the table to get from
   * 
   * @var string
   */
  public $table = null;
  /**
   * a list of TGets to fetch, the Result list
   * will have the Results at corresponding positions
   * or null if there was an error
   * 
   * @var TGet[]
   */
  public $tgets = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['tgets'])) {
        $this->tgets = $vals['tgets'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_getMultiple_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->tgets = array();
            $_size117 = 0;
            $_etype120 = 0;
            $xfer += $input->readListBegin($_etype120, $_size117);
            for ($_i121 = 0; $_i121 < $_size117; ++$_i121)
            {
              $elem122 = null;
              $elem122 = new TGet();
              $xfer += $elem122->read($input);
              $this->tgets []= $elem122;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_getMultiple_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tgets !== null) {
      if (!is_array($this->tgets)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tgets', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->tgets));
        {
          foreach ($this->tgets as $iter123)
          {
            $xfer += $iter123->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_getMultiple_result {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\TResult',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var TResult[]
   */
  public $success = null;
  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_getMultiple_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size124 = 0;
            $_etype127 = 0;
            $xfer += $input->readListBegin($_etype127, $_size124);
            for ($_i128 = 0; $_i128 < $_size124; ++$_i128)
            {
              $elem129 = null;
              $elem129 = new TResult();
              $xfer += $elem129->read($input);
              $this->success []= $elem129;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_getMultiple_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter130)
          {
            $xfer += $iter130->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_put_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'tput',
      'isRequired' => true,
      'type' => TType::STRUCT,
      'class' => '\TPut',
      ),
    );

  /**
   * the table to put data in
   * 
   * @var string
   */
  public $table = null;
  /**
   * the TPut to put
   * 
   * @var TPut
   */
  public $tput = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['tput'])) {
        $this->tput = $vals['tput'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_put_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->tput = new TPut();
            $xfer += $this->tput->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_put_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tput !== null) {
      if (!is_object($this->tput)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tput', TType::STRUCT, 2);
      $xfer += $this->tput->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_put_result {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_put_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_put_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_checkAndPut_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'family',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'qualifier',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    5 => array(
      'var' => 'value',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    6 => array(
      'var' => 'tput',
      'isRequired' => true,
      'type' => TType::STRUCT,
      'class' => '\TPut',
      ),
    );

  /**
   * to check in and put to
   * 
   * @var string
   */
  public $table = null;
  /**
   * row to check
   * 
   * @var string
   */
  public $row = null;
  /**
   * column family to check
   * 
   * @var string
   */
  public $family = null;
  /**
   * column qualifier to check
   * 
   * @var string
   */
  public $qualifier = null;
  /**
   * the expected value, if not provided the
   * check is for the non-existence of the
   * column in question
   * 
   * @var string
   */
  public $value = null;
  /**
   * the TPut to put if the check succeeds
   * 
   * @var TPut
   */
  public $tput = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['family'])) {
        $this->family = $vals['family'];
      }
      if (isset($vals['qualifier'])) {
        $this->qualifier = $vals['qualifier'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
      if (isset($vals['tput'])) {
        $this->tput = $vals['tput'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_checkAndPut_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->family);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->qualifier);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->tput = new TPut();
            $xfer += $this->tput->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_checkAndPut_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->family !== null) {
      $xfer += $output->writeFieldBegin('family', TType::STRING, 3);
      $xfer += $output->writeString($this->family);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qualifier !== null) {
      $xfer += $output->writeFieldBegin('qualifier', TType::STRING, 4);
      $xfer += $output->writeString($this->qualifier);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 5);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tput !== null) {
      if (!is_object($this->tput)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tput', TType::STRUCT, 6);
      $xfer += $this->tput->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_checkAndPut_result {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_checkAndPut_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_checkAndPut_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_putMultiple_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'tputs',
      'isRequired' => true,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\TPut',
        ),
      ),
    );

  /**
   * the table to put data in
   * 
   * @var string
   */
  public $table = null;
  /**
   * a list of TPuts to commit
   * 
   * @var TPut[]
   */
  public $tputs = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['tputs'])) {
        $this->tputs = $vals['tputs'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_putMultiple_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->tputs = array();
            $_size131 = 0;
            $_etype134 = 0;
            $xfer += $input->readListBegin($_etype134, $_size131);
            for ($_i135 = 0; $_i135 < $_size131; ++$_i135)
            {
              $elem136 = null;
              $elem136 = new TPut();
              $xfer += $elem136->read($input);
              $this->tputs []= $elem136;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_putMultiple_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tputs !== null) {
      if (!is_array($this->tputs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tputs', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->tputs));
        {
          foreach ($this->tputs as $iter137)
          {
            $xfer += $iter137->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_putMultiple_result {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_putMultiple_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_putMultiple_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_deleteSingle_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'tdelete',
      'isRequired' => true,
      'type' => TType::STRUCT,
      'class' => '\TDelete',
      ),
    );

  /**
   * the table to delete from
   * 
   * @var string
   */
  public $table = null;
  /**
   * the TDelete to delete
   * 
   * @var TDelete
   */
  public $tdelete = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['tdelete'])) {
        $this->tdelete = $vals['tdelete'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_deleteSingle_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->tdelete = new TDelete();
            $xfer += $this->tdelete->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_deleteSingle_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tdelete !== null) {
      if (!is_object($this->tdelete)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tdelete', TType::STRUCT, 2);
      $xfer += $this->tdelete->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_deleteSingle_result {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_deleteSingle_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_deleteSingle_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_deleteMultiple_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'tdeletes',
      'isRequired' => true,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\TDelete',
        ),
      ),
    );

  /**
   * the table to delete from
   * 
   * @var string
   */
  public $table = null;
  /**
   * list of TDeletes to delete
   * 
   * @var TDelete[]
   */
  public $tdeletes = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['tdeletes'])) {
        $this->tdeletes = $vals['tdeletes'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_deleteMultiple_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->tdeletes = array();
            $_size138 = 0;
            $_etype141 = 0;
            $xfer += $input->readListBegin($_etype141, $_size138);
            for ($_i142 = 0; $_i142 < $_size138; ++$_i142)
            {
              $elem143 = null;
              $elem143 = new TDelete();
              $xfer += $elem143->read($input);
              $this->tdeletes []= $elem143;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_deleteMultiple_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tdeletes !== null) {
      if (!is_array($this->tdeletes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tdeletes', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->tdeletes));
        {
          foreach ($this->tdeletes as $iter144)
          {
            $xfer += $iter144->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_deleteMultiple_result {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\TDelete',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var TDelete[]
   */
  public $success = null;
  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_deleteMultiple_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size145 = 0;
            $_etype148 = 0;
            $xfer += $input->readListBegin($_etype148, $_size145);
            for ($_i149 = 0; $_i149 < $_size145; ++$_i149)
            {
              $elem150 = null;
              $elem150 = new TDelete();
              $xfer += $elem150->read($input);
              $this->success []= $elem150;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_deleteMultiple_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter151)
          {
            $xfer += $iter151->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_checkAndDelete_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'family',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'qualifier',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    5 => array(
      'var' => 'value',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    6 => array(
      'var' => 'tdelete',
      'isRequired' => true,
      'type' => TType::STRUCT,
      'class' => '\TDelete',
      ),
    );

  /**
   * to check in and delete from
   * 
   * @var string
   */
  public $table = null;
  /**
   * row to check
   * 
   * @var string
   */
  public $row = null;
  /**
   * column family to check
   * 
   * @var string
   */
  public $family = null;
  /**
   * column qualifier to check
   * 
   * @var string
   */
  public $qualifier = null;
  /**
   * the expected value, if not provided the
   * check is for the non-existence of the
   * column in question
   * 
   * @var string
   */
  public $value = null;
  /**
   * the TDelete to execute if the check succeeds
   * 
   * @var TDelete
   */
  public $tdelete = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['family'])) {
        $this->family = $vals['family'];
      }
      if (isset($vals['qualifier'])) {
        $this->qualifier = $vals['qualifier'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
      if (isset($vals['tdelete'])) {
        $this->tdelete = $vals['tdelete'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_checkAndDelete_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->family);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->qualifier);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->tdelete = new TDelete();
            $xfer += $this->tdelete->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_checkAndDelete_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->family !== null) {
      $xfer += $output->writeFieldBegin('family', TType::STRING, 3);
      $xfer += $output->writeString($this->family);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qualifier !== null) {
      $xfer += $output->writeFieldBegin('qualifier', TType::STRING, 4);
      $xfer += $output->writeString($this->qualifier);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 5);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tdelete !== null) {
      if (!is_object($this->tdelete)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tdelete', TType::STRUCT, 6);
      $xfer += $this->tdelete->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_checkAndDelete_result {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_checkAndDelete_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_checkAndDelete_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_increment_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'tincrement',
      'isRequired' => true,
      'type' => TType::STRUCT,
      'class' => '\TIncrement',
      ),
    );

  /**
   * the table to increment the value on
   * 
   * @var string
   */
  public $table = null;
  /**
   * the TIncrement to increment
   * 
   * @var TIncrement
   */
  public $tincrement = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['tincrement'])) {
        $this->tincrement = $vals['tincrement'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_increment_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->tincrement = new TIncrement();
            $xfer += $this->tincrement->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_increment_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tincrement !== null) {
      if (!is_object($this->tincrement)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tincrement', TType::STRUCT, 2);
      $xfer += $this->tincrement->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_increment_result {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TResult',
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var TResult
   */
  public $success = null;
  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_increment_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new TResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_increment_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_append_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'tappend',
      'isRequired' => true,
      'type' => TType::STRUCT,
      'class' => '\TAppend',
      ),
    );

  /**
   * the table to append the value on
   * 
   * @var string
   */
  public $table = null;
  /**
   * the TAppend to append
   * 
   * @var TAppend
   */
  public $tappend = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['tappend'])) {
        $this->tappend = $vals['tappend'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_append_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->tappend = new TAppend();
            $xfer += $this->tappend->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_append_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tappend !== null) {
      if (!is_object($this->tappend)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tappend', TType::STRUCT, 2);
      $xfer += $this->tappend->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_append_result {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TResult',
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var TResult
   */
  public $success = null;
  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_append_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new TResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_append_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_openScanner_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'tscan',
      'isRequired' => true,
      'type' => TType::STRUCT,
      'class' => '\TScan',
      ),
    );

  /**
   * the table to get the Scanner for
   * 
   * @var string
   */
  public $table = null;
  /**
   * the scan object to get a Scanner for
   * 
   * @var TScan
   */
  public $tscan = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['tscan'])) {
        $this->tscan = $vals['tscan'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_openScanner_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->tscan = new TScan();
            $xfer += $this->tscan->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_openScanner_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tscan !== null) {
      if (!is_object($this->tscan)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tscan', TType::STRUCT, 2);
      $xfer += $this->tscan->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_openScanner_result {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var int
   */
  public $success = null;
  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_openScanner_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_openScanner_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_getScannerRows_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'scannerId',
      'isRequired' => true,
      'type' => TType::I32,
      ),
    2 => array(
      'var' => 'numRows',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    );

  /**
   * the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
   * 
   * @var int
   */
  public $scannerId = null;
  /**
   * number of rows to return
   * 
   * @var int
   */
  public $numRows = 1;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['scannerId'])) {
        $this->scannerId = $vals['scannerId'];
      }
      if (isset($vals['numRows'])) {
        $this->numRows = $vals['numRows'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_getScannerRows_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->scannerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->numRows);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_getScannerRows_args');
    if ($this->scannerId !== null) {
      $xfer += $output->writeFieldBegin('scannerId', TType::I32, 1);
      $xfer += $output->writeI32($this->scannerId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numRows !== null) {
      $xfer += $output->writeFieldBegin('numRows', TType::I32, 2);
      $xfer += $output->writeI32($this->numRows);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_getScannerRows_result {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\TResult',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    2 => array(
      'var' => 'ia',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIllegalArgument',
      ),
    );

  /**
   * @var TResult[]
   */
  public $success = null;
  /**
   * @var TIOError
   */
  public $io = null;
  /**
   * if the scannerId is invalid
   * 
   * @var TIllegalArgument
   */
  public $ia = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_getScannerRows_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size152 = 0;
            $_etype155 = 0;
            $xfer += $input->readListBegin($_etype155, $_size152);
            for ($_i156 = 0; $_i156 < $_size152; ++$_i156)
            {
              $elem157 = null;
              $elem157 = new TResult();
              $xfer += $elem157->read($input);
              $this->success []= $elem157;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new TIllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_getScannerRows_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter158)
          {
            $xfer += $iter158->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_closeScanner_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'scannerId',
      'isRequired' => true,
      'type' => TType::I32,
      ),
    );

  /**
   * the Id of the Scanner to close *
   * 
   * @var int
   */
  public $scannerId = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['scannerId'])) {
        $this->scannerId = $vals['scannerId'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_closeScanner_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->scannerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_closeScanner_args');
    if ($this->scannerId !== null) {
      $xfer += $output->writeFieldBegin('scannerId', TType::I32, 1);
      $xfer += $output->writeI32($this->scannerId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_closeScanner_result {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    2 => array(
      'var' => 'ia',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIllegalArgument',
      ),
    );

  /**
   * @var TIOError
   */
  public $io = null;
  /**
   * if the scannerId is invalid
   * 
   * @var TIllegalArgument
   */
  public $ia = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_closeScanner_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new TIllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_closeScanner_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_mutateRow_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'trowMutations',
      'isRequired' => true,
      'type' => TType::STRUCT,
      'class' => '\TRowMutations',
      ),
    );

  /**
   * table to apply the mutations
   * 
   * @var string
   */
  public $table = null;
  /**
   * mutations to apply
   * 
   * @var TRowMutations
   */
  public $trowMutations = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['trowMutations'])) {
        $this->trowMutations = $vals['trowMutations'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_mutateRow_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->trowMutations = new TRowMutations();
            $xfer += $this->trowMutations->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_mutateRow_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->trowMutations !== null) {
      if (!is_object($this->trowMutations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('trowMutations', TType::STRUCT, 2);
      $xfer += $this->trowMutations->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_mutateRow_result {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_mutateRow_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_mutateRow_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_getScannerResults_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'tscan',
      'isRequired' => true,
      'type' => TType::STRUCT,
      'class' => '\TScan',
      ),
    3 => array(
      'var' => 'numRows',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    );

  /**
   * the table to get the Scanner for
   * 
   * @var string
   */
  public $table = null;
  /**
   * the scan object to get a Scanner for
   * 
   * @var TScan
   */
  public $tscan = null;
  /**
   * number of rows to return
   * 
   * @var int
   */
  public $numRows = 1;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['tscan'])) {
        $this->tscan = $vals['tscan'];
      }
      if (isset($vals['numRows'])) {
        $this->numRows = $vals['numRows'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_getScannerResults_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->tscan = new TScan();
            $xfer += $this->tscan->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->numRows);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_getScannerResults_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tscan !== null) {
      if (!is_object($this->tscan)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tscan', TType::STRUCT, 2);
      $xfer += $this->tscan->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numRows !== null) {
      $xfer += $output->writeFieldBegin('numRows', TType::I32, 3);
      $xfer += $output->writeI32($this->numRows);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_getScannerResults_result {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\TResult',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var TResult[]
   */
  public $success = null;
  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_getScannerResults_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size159 = 0;
            $_etype162 = 0;
            $xfer += $input->readListBegin($_etype162, $_size159);
            for ($_i163 = 0; $_i163 < $_size159; ++$_i163)
            {
              $elem164 = null;
              $elem164 = new TResult();
              $xfer += $elem164->read($input);
              $this->success []= $elem164;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_getScannerResults_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter165)
          {
            $xfer += $iter165->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_getRegionLocation_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'reload',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    );

  /**
   * @var string
   */
  public $table = null;
  /**
   * @var string
   */
  public $row = null;
  /**
   * @var bool
   */
  public $reload = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['reload'])) {
        $this->reload = $vals['reload'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_getRegionLocation_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->reload);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_getRegionLocation_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->reload !== null) {
      $xfer += $output->writeFieldBegin('reload', TType::BOOL, 3);
      $xfer += $output->writeBool($this->reload);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_getRegionLocation_result {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\THRegionLocation',
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var THRegionLocation
   */
  public $success = null;
  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_getRegionLocation_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new THRegionLocation();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_getRegionLocation_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_getAllRegionLocations_args {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    );

  /**
   * @var string
   */
  public $table = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_getAllRegionLocations_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_getAllRegionLocations_args');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseService_getAllRegionLocations_result {
  static $isValidate = false;

  static $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\THRegionLocation',
        ),
      ),
    1 => array(
      'var' => 'io',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TIOError',
      ),
    );

  /**
   * @var THRegionLocation[]
   */
  public $success = null;
  /**
   * @var TIOError
   */
  public $io = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'THBaseService_getAllRegionLocations_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size166 = 0;
            $_etype169 = 0;
            $xfer += $input->readListBegin($_etype169, $_size166);
            for ($_i170 = 0; $_i170 < $_size166; ++$_i170)
            {
              $elem171 = null;
              $elem171 = new THRegionLocation();
              $xfer += $elem171->read($input);
              $this->success []= $elem171;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new TIOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseService_getAllRegionLocations_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter172)
          {
            $xfer += $iter172->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


