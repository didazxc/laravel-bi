<?php

namespace Zxc\Thrift\Hbase;

/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


/**
 * Specify type of delete:
 *  - DELETE_COLUMN means exactly one version will be removed,
 *  - DELETE_COLUMNS means previous versions will also be removed.
 */
final class TDeleteType {
  const DELETE_COLUMN = 0;
  const DELETE_COLUMNS = 1;
  static public $__names = array(
    0 => 'DELETE_COLUMN',
    1 => 'DELETE_COLUMNS',
  );
}

/**
 * Specify Durability:
 *  - SKIP_WAL means do not write the Mutation to the WAL.
 *  - ASYNC_WAL means write the Mutation to the WAL asynchronously,
 *  - SYNC_WAL means write the Mutation to the WAL synchronously,
 *  - FSYNC_WAL means Write the Mutation to the WAL synchronously and force the entries to disk.
 */
final class TDurability {
  const SKIP_WAL = 1;
  const ASYNC_WAL = 2;
  const SYNC_WAL = 3;
  const FSYNC_WAL = 4;
  static public $__names = array(
    1 => 'SKIP_WAL',
    2 => 'ASYNC_WAL',
    3 => 'SYNC_WAL',
    4 => 'FSYNC_WAL',
  );
}

class TTimeRange {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'minStamp',
      'isRequired' => true,
      'type' => TType::I64,
      ),
    2 => array(
      'var' => 'maxStamp',
      'isRequired' => true,
      'type' => TType::I64,
      ),
    );

  /**
   * @var int
   */
  public $minStamp = null;
  /**
   * @var int
   */
  public $maxStamp = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['minStamp'])) {
        $this->minStamp = $vals['minStamp'];
      }
      if (isset($vals['maxStamp'])) {
        $this->maxStamp = $vals['maxStamp'];
      }
    }
  }

  public function getName() {
    return 'TTimeRange';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->minStamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->maxStamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TTimeRange');
    if ($this->minStamp !== null) {
      $xfer += $output->writeFieldBegin('minStamp', TType::I64, 1);
      $xfer += $output->writeI64($this->minStamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxStamp !== null) {
      $xfer += $output->writeFieldBegin('maxStamp', TType::I64, 2);
      $xfer += $output->writeI64($this->maxStamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Addresses a single cell or multiple cells
 * in a HBase table by column family and optionally
 * a column qualifier and timestamp
 */
class TColumn {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'family',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'qualifier',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    );

  /**
   * @var string
   */
  public $family = null;
  /**
   * @var string
   */
  public $qualifier = null;
  /**
   * @var int
   */
  public $timestamp = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['family'])) {
        $this->family = $vals['family'];
      }
      if (isset($vals['qualifier'])) {
        $this->qualifier = $vals['qualifier'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'TColumn';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->family);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->qualifier);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TColumn');
    if ($this->family !== null) {
      $xfer += $output->writeFieldBegin('family', TType::STRING, 1);
      $xfer += $output->writeString($this->family);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qualifier !== null) {
      $xfer += $output->writeFieldBegin('qualifier', TType::STRING, 2);
      $xfer += $output->writeString($this->qualifier);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Represents a single cell and its value.
 */
class TColumnValue {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'family',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'qualifier',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'value',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    5 => array(
      'var' => 'tags',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * @var string
   */
  public $family = null;
  /**
   * @var string
   */
  public $qualifier = null;
  /**
   * @var string
   */
  public $value = null;
  /**
   * @var int
   */
  public $timestamp = null;
  /**
   * @var string
   */
  public $tags = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['family'])) {
        $this->family = $vals['family'];
      }
      if (isset($vals['qualifier'])) {
        $this->qualifier = $vals['qualifier'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
      if (isset($vals['tags'])) {
        $this->tags = $vals['tags'];
      }
    }
  }

  public function getName() {
    return 'TColumnValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->family);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->qualifier);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tags);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TColumnValue');
    if ($this->family !== null) {
      $xfer += $output->writeFieldBegin('family', TType::STRING, 1);
      $xfer += $output->writeString($this->family);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qualifier !== null) {
      $xfer += $output->writeFieldBegin('qualifier', TType::STRING, 2);
      $xfer += $output->writeString($this->qualifier);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 3);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tags !== null) {
      $xfer += $output->writeFieldBegin('tags', TType::STRING, 5);
      $xfer += $output->writeString($this->tags);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Represents a single cell and the amount to increment it by
 */
class TColumnIncrement {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'family',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'qualifier',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'amount',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    );

  /**
   * @var string
   */
  public $family = null;
  /**
   * @var string
   */
  public $qualifier = null;
  /**
   * @var int
   */
  public $amount = 1;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['family'])) {
        $this->family = $vals['family'];
      }
      if (isset($vals['qualifier'])) {
        $this->qualifier = $vals['qualifier'];
      }
      if (isset($vals['amount'])) {
        $this->amount = $vals['amount'];
      }
    }
  }

  public function getName() {
    return 'TColumnIncrement';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->family);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->qualifier);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->amount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TColumnIncrement');
    if ($this->family !== null) {
      $xfer += $output->writeFieldBegin('family', TType::STRING, 1);
      $xfer += $output->writeString($this->family);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qualifier !== null) {
      $xfer += $output->writeFieldBegin('qualifier', TType::STRING, 2);
      $xfer += $output->writeString($this->qualifier);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->amount !== null) {
      $xfer += $output->writeFieldBegin('amount', TType::I64, 3);
      $xfer += $output->writeI64($this->amount);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * if no Result is found, row and columnValues will not be set.
 */
class TResult {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'columnValues',
      'isRequired' => true,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\TColumnValue',
        ),
      ),
    );

  /**
   * @var string
   */
  public $row = null;
  /**
   * @var TColumnValue[]
   */
  public $columnValues = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['columnValues'])) {
        $this->columnValues = $vals['columnValues'];
      }
    }
  }

  public function getName() {
    return 'TResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columnValues = array();
            $_size0 = 0;
            $_etype3 = 0;
            $xfer += $input->readListBegin($_etype3, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $elem5 = new TColumnValue();
              $xfer += $elem5->read($input);
              $this->columnValues []= $elem5;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TResult');
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columnValues !== null) {
      if (!is_array($this->columnValues)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columnValues', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->columnValues));
        {
          foreach ($this->columnValues as $iter6)
          {
            $xfer += $iter6->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TAuthorization {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'labels',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * @var string[]
   */
  public $labels = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['labels'])) {
        $this->labels = $vals['labels'];
      }
    }
  }

  public function getName() {
    return 'TAuthorization';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->labels = array();
            $_size7 = 0;
            $_etype10 = 0;
            $xfer += $input->readListBegin($_etype10, $_size7);
            for ($_i11 = 0; $_i11 < $_size7; ++$_i11)
            {
              $elem12 = null;
              $xfer += $input->readString($elem12);
              $this->labels []= $elem12;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TAuthorization');
    if ($this->labels !== null) {
      if (!is_array($this->labels)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('labels', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->labels));
        {
          foreach ($this->labels as $iter13)
          {
            $xfer += $output->writeString($iter13);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCellVisibility {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'expression',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * @var string
   */
  public $expression = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['expression'])) {
        $this->expression = $vals['expression'];
      }
    }
  }

  public function getName() {
    return 'TCellVisibility';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expression);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCellVisibility');
    if ($this->expression !== null) {
      $xfer += $output->writeFieldBegin('expression', TType::STRING, 1);
      $xfer += $output->writeString($this->expression);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Used to perform Get operations on a single row.
 *
 * The scope can be further narrowed down by specifying a list of
 * columns or column families.
 *
 * To get everything for a row, instantiate a Get object with just the row to get.
 * To further define the scope of what to get you can add a timestamp or time range
 * with an optional maximum number of versions to return.
 *
 * If you specify a time range and a timestamp the range is ignored.
 * Timestamps on TColumns are ignored.
 */
class TGet {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'row',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'columns',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\TColumn',
        ),
      ),
    3 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    4 => array(
      'var' => 'timeRange',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TTimeRange',
      ),
    5 => array(
      'var' => 'maxVersions',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    6 => array(
      'var' => 'filterString',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    7 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    8 => array(
      'var' => 'authorizations',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TAuthorization',
      ),
    );

  /**
   * @var string
   */
  public $row = null;
  /**
   * @var TColumn[]
   */
  public $columns = null;
  /**
   * @var int
   */
  public $timestamp = null;
  /**
   * @var TTimeRange
   */
  public $timeRange = null;
  /**
   * @var int
   */
  public $maxVersions = null;
  /**
   * @var string
   */
  public $filterString = null;
  /**
   * @var array
   */
  public $attributes = null;
  /**
   * @var TAuthorization
   */
  public $authorizations = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
      if (isset($vals['timeRange'])) {
        $this->timeRange = $vals['timeRange'];
      }
      if (isset($vals['maxVersions'])) {
        $this->maxVersions = $vals['maxVersions'];
      }
      if (isset($vals['filterString'])) {
        $this->filterString = $vals['filterString'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['authorizations'])) {
        $this->authorizations = $vals['authorizations'];
      }
    }
  }

  public function getName() {
    return 'TGet';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size14 = 0;
            $_etype17 = 0;
            $xfer += $input->readListBegin($_etype17, $_size14);
            for ($_i18 = 0; $_i18 < $_size14; ++$_i18)
            {
              $elem19 = null;
              $elem19 = new TColumn();
              $xfer += $elem19->read($input);
              $this->columns []= $elem19;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->timeRange = new TTimeRange();
            $xfer += $this->timeRange->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->maxVersions);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filterString);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::MAP) {
            $this->attributes = array();
            $_size20 = 0;
            $_ktype21 = 0;
            $_vtype22 = 0;
            $xfer += $input->readMapBegin($_ktype21, $_vtype22, $_size20);
            for ($_i24 = 0; $_i24 < $_size20; ++$_i24)
            {
              $key25 = '';
              $val26 = '';
              $xfer += $input->readString($key25);
              $xfer += $input->readString($val26);
              $this->attributes[$key25] = $val26;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRUCT) {
            $this->authorizations = new TAuthorization();
            $xfer += $this->authorizations->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGet');
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->columns));
        {
          foreach ($this->columns as $iter27)
          {
            $xfer += $iter27->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timeRange !== null) {
      if (!is_object($this->timeRange)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('timeRange', TType::STRUCT, 4);
      $xfer += $this->timeRange->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxVersions !== null) {
      $xfer += $output->writeFieldBegin('maxVersions', TType::I32, 5);
      $xfer += $output->writeI32($this->maxVersions);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filterString !== null) {
      $xfer += $output->writeFieldBegin('filterString', TType::STRING, 6);
      $xfer += $output->writeString($this->filterString);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_array($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::MAP, 7);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->attributes));
        {
          foreach ($this->attributes as $kiter28 => $viter29)
          {
            $xfer += $output->writeString($kiter28);
            $xfer += $output->writeString($viter29);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->authorizations !== null) {
      if (!is_object($this->authorizations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('authorizations', TType::STRUCT, 8);
      $xfer += $this->authorizations->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Used to perform Put operations for a single row.
 * 
 * Add column values to this object and they'll be added.
 * You can provide a default timestamp if the column values
 * don't have one. If you don't provide a default timestamp
 * the current time is inserted.
 * 
 * You can specify how this Put should be written to the write-ahead Log (WAL)
 * by changing the durability. If you don't provide durability, it defaults to
 * column family's default setting for durability.
 */
class TPut {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'row',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'columnValues',
      'isRequired' => true,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\TColumnValue',
        ),
      ),
    3 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    5 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    6 => array(
      'var' => 'durability',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    7 => array(
      'var' => 'cellVisibility',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TCellVisibility',
      ),
    );

  /**
   * @var string
   */
  public $row = null;
  /**
   * @var TColumnValue[]
   */
  public $columnValues = null;
  /**
   * @var int
   */
  public $timestamp = null;
  /**
   * @var array
   */
  public $attributes = null;
  /**
   * @var int
   */
  public $durability = null;
  /**
   * @var TCellVisibility
   */
  public $cellVisibility = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['columnValues'])) {
        $this->columnValues = $vals['columnValues'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['durability'])) {
        $this->durability = $vals['durability'];
      }
      if (isset($vals['cellVisibility'])) {
        $this->cellVisibility = $vals['cellVisibility'];
      }
    }
  }

  public function getName() {
    return 'TPut';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columnValues = array();
            $_size30 = 0;
            $_etype33 = 0;
            $xfer += $input->readListBegin($_etype33, $_size30);
            for ($_i34 = 0; $_i34 < $_size30; ++$_i34)
            {
              $elem35 = null;
              $elem35 = new TColumnValue();
              $xfer += $elem35->read($input);
              $this->columnValues []= $elem35;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->attributes = array();
            $_size36 = 0;
            $_ktype37 = 0;
            $_vtype38 = 0;
            $xfer += $input->readMapBegin($_ktype37, $_vtype38, $_size36);
            for ($_i40 = 0; $_i40 < $_size36; ++$_i40)
            {
              $key41 = '';
              $val42 = '';
              $xfer += $input->readString($key41);
              $xfer += $input->readString($val42);
              $this->attributes[$key41] = $val42;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->durability);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->cellVisibility = new TCellVisibility();
            $xfer += $this->cellVisibility->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TPut');
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columnValues !== null) {
      if (!is_array($this->columnValues)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columnValues', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->columnValues));
        {
          foreach ($this->columnValues as $iter43)
          {
            $xfer += $iter43->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_array($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->attributes));
        {
          foreach ($this->attributes as $kiter44 => $viter45)
          {
            $xfer += $output->writeString($kiter44);
            $xfer += $output->writeString($viter45);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->durability !== null) {
      $xfer += $output->writeFieldBegin('durability', TType::I32, 6);
      $xfer += $output->writeI32($this->durability);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cellVisibility !== null) {
      if (!is_object($this->cellVisibility)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('cellVisibility', TType::STRUCT, 7);
      $xfer += $this->cellVisibility->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Used to perform Delete operations on a single row.
 * 
 * The scope can be further narrowed down by specifying a list of
 * columns or column families as TColumns.
 * 
 * Specifying only a family in a TColumn will delete the whole family.
 * If a timestamp is specified all versions with a timestamp less than
 * or equal to this will be deleted. If no timestamp is specified the
 * current time will be used.
 * 
 * Specifying a family and a column qualifier in a TColumn will delete only
 * this qualifier. If a timestamp is specified only versions equal
 * to this timestamp will be deleted. If no timestamp is specified the
 * most recent version will be deleted.  To delete all previous versions,
 * specify the DELETE_COLUMNS TDeleteType.
 * 
 * The top level timestamp is only used if a complete row should be deleted
 * (i.e. no columns are passed) and if it is specified it works the same way
 * as if you had added a TColumn for every column family and this timestamp
 * (i.e. all versions older than or equal in all column families will be deleted)
 * 
 * You can specify how this Delete should be written to the write-ahead Log (WAL)
 * by changing the durability. If you don't provide durability, it defaults to
 * column family's default setting for durability.
 */
class TDelete {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'row',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'columns',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\TColumn',
        ),
      ),
    3 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    4 => array(
      'var' => 'deleteType',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    6 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    7 => array(
      'var' => 'durability',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    );

  /**
   * @var string
   */
  public $row = null;
  /**
   * @var TColumn[]
   */
  public $columns = null;
  /**
   * @var int
   */
  public $timestamp = null;
  /**
   * @var int
   */
  public $deleteType =   1;
  /**
   * @var array
   */
  public $attributes = null;
  /**
   * @var int
   */
  public $durability = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
      if (isset($vals['deleteType'])) {
        $this->deleteType = $vals['deleteType'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['durability'])) {
        $this->durability = $vals['durability'];
      }
    }
  }

  public function getName() {
    return 'TDelete';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size46 = 0;
            $_etype49 = 0;
            $xfer += $input->readListBegin($_etype49, $_size46);
            for ($_i50 = 0; $_i50 < $_size46; ++$_i50)
            {
              $elem51 = null;
              $elem51 = new TColumn();
              $xfer += $elem51->read($input);
              $this->columns []= $elem51;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->deleteType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::MAP) {
            $this->attributes = array();
            $_size52 = 0;
            $_ktype53 = 0;
            $_vtype54 = 0;
            $xfer += $input->readMapBegin($_ktype53, $_vtype54, $_size52);
            for ($_i56 = 0; $_i56 < $_size52; ++$_i56)
            {
              $key57 = '';
              $val58 = '';
              $xfer += $input->readString($key57);
              $xfer += $input->readString($val58);
              $this->attributes[$key57] = $val58;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->durability);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TDelete');
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->columns));
        {
          foreach ($this->columns as $iter59)
          {
            $xfer += $iter59->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteType !== null) {
      $xfer += $output->writeFieldBegin('deleteType', TType::I32, 4);
      $xfer += $output->writeI32($this->deleteType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_array($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::MAP, 6);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->attributes));
        {
          foreach ($this->attributes as $kiter60 => $viter61)
          {
            $xfer += $output->writeString($kiter60);
            $xfer += $output->writeString($viter61);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->durability !== null) {
      $xfer += $output->writeFieldBegin('durability', TType::I32, 7);
      $xfer += $output->writeI32($this->durability);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Used to perform Increment operations for a single row.
 * 
 * You can specify how this Increment should be written to the write-ahead Log (WAL)
 * by changing the durability. If you don't provide durability, it defaults to
 * column family's default setting for durability.
 */
class TIncrement {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'row',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'columns',
      'isRequired' => true,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\TColumnIncrement',
        ),
      ),
    4 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    5 => array(
      'var' => 'durability',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    6 => array(
      'var' => 'cellVisibility',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TCellVisibility',
      ),
    );

  /**
   * @var string
   */
  public $row = null;
  /**
   * @var TColumnIncrement[]
   */
  public $columns = null;
  /**
   * @var array
   */
  public $attributes = null;
  /**
   * @var int
   */
  public $durability = null;
  /**
   * @var TCellVisibility
   */
  public $cellVisibility = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['durability'])) {
        $this->durability = $vals['durability'];
      }
      if (isset($vals['cellVisibility'])) {
        $this->cellVisibility = $vals['cellVisibility'];
      }
    }
  }

  public function getName() {
    return 'TIncrement';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size62 = 0;
            $_etype65 = 0;
            $xfer += $input->readListBegin($_etype65, $_size62);
            for ($_i66 = 0; $_i66 < $_size62; ++$_i66)
            {
              $elem67 = null;
              $elem67 = new TColumnIncrement();
              $xfer += $elem67->read($input);
              $this->columns []= $elem67;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->attributes = array();
            $_size68 = 0;
            $_ktype69 = 0;
            $_vtype70 = 0;
            $xfer += $input->readMapBegin($_ktype69, $_vtype70, $_size68);
            for ($_i72 = 0; $_i72 < $_size68; ++$_i72)
            {
              $key73 = '';
              $val74 = '';
              $xfer += $input->readString($key73);
              $xfer += $input->readString($val74);
              $this->attributes[$key73] = $val74;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->durability);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->cellVisibility = new TCellVisibility();
            $xfer += $this->cellVisibility->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TIncrement');
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->columns));
        {
          foreach ($this->columns as $iter75)
          {
            $xfer += $iter75->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_array($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->attributes));
        {
          foreach ($this->attributes as $kiter76 => $viter77)
          {
            $xfer += $output->writeString($kiter76);
            $xfer += $output->writeString($viter77);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->durability !== null) {
      $xfer += $output->writeFieldBegin('durability', TType::I32, 5);
      $xfer += $output->writeI32($this->durability);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cellVisibility !== null) {
      if (!is_object($this->cellVisibility)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('cellVisibility', TType::STRUCT, 6);
      $xfer += $this->cellVisibility->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TAppend {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'row',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'columns',
      'isRequired' => true,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\TColumnValue',
        ),
      ),
    3 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    4 => array(
      'var' => 'durability',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    5 => array(
      'var' => 'cellVisibility',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TCellVisibility',
      ),
    );

  /**
   * @var string
   */
  public $row = null;
  /**
   * @var TColumnValue[]
   */
  public $columns = null;
  /**
   * @var array
   */
  public $attributes = null;
  /**
   * @var int
   */
  public $durability = null;
  /**
   * @var TCellVisibility
   */
  public $cellVisibility = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['durability'])) {
        $this->durability = $vals['durability'];
      }
      if (isset($vals['cellVisibility'])) {
        $this->cellVisibility = $vals['cellVisibility'];
      }
    }
  }

  public function getName() {
    return 'TAppend';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size78 = 0;
            $_etype81 = 0;
            $xfer += $input->readListBegin($_etype81, $_size78);
            for ($_i82 = 0; $_i82 < $_size78; ++$_i82)
            {
              $elem83 = null;
              $elem83 = new TColumnValue();
              $xfer += $elem83->read($input);
              $this->columns []= $elem83;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->attributes = array();
            $_size84 = 0;
            $_ktype85 = 0;
            $_vtype86 = 0;
            $xfer += $input->readMapBegin($_ktype85, $_vtype86, $_size84);
            for ($_i88 = 0; $_i88 < $_size84; ++$_i88)
            {
              $key89 = '';
              $val90 = '';
              $xfer += $input->readString($key89);
              $xfer += $input->readString($val90);
              $this->attributes[$key89] = $val90;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->durability);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->cellVisibility = new TCellVisibility();
            $xfer += $this->cellVisibility->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TAppend');
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->columns));
        {
          foreach ($this->columns as $iter91)
          {
            $xfer += $iter91->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_array($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->attributes));
        {
          foreach ($this->attributes as $kiter92 => $viter93)
          {
            $xfer += $output->writeString($kiter92);
            $xfer += $output->writeString($viter93);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->durability !== null) {
      $xfer += $output->writeFieldBegin('durability', TType::I32, 4);
      $xfer += $output->writeI32($this->durability);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cellVisibility !== null) {
      if (!is_object($this->cellVisibility)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('cellVisibility', TType::STRUCT, 5);
      $xfer += $this->cellVisibility->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Any timestamps in the columns are ignored, use timeRange to select by timestamp.
 * Max versions defaults to 1.
 */
class TScan {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'startRow',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'stopRow',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'columns',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\TColumn',
        ),
      ),
    4 => array(
      'var' => 'caching',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    5 => array(
      'var' => 'maxVersions',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    6 => array(
      'var' => 'timeRange',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TTimeRange',
      ),
    7 => array(
      'var' => 'filterString',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    8 => array(
      'var' => 'batchSize',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    9 => array(
      'var' => 'attributes',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRING,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRING,
        ),
      ),
    10 => array(
      'var' => 'authorizations',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TAuthorization',
      ),
    11 => array(
      'var' => 'reversed',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    );

  /**
   * @var string
   */
  public $startRow = null;
  /**
   * @var string
   */
  public $stopRow = null;
  /**
   * @var TColumn[]
   */
  public $columns = null;
  /**
   * @var int
   */
  public $caching = null;
  /**
   * @var int
   */
  public $maxVersions = 1;
  /**
   * @var TTimeRange
   */
  public $timeRange = null;
  /**
   * @var string
   */
  public $filterString = null;
  /**
   * @var int
   */
  public $batchSize = null;
  /**
   * @var array
   */
  public $attributes = null;
  /**
   * @var TAuthorization
   */
  public $authorizations = null;
  /**
   * @var bool
   */
  public $reversed = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['caching'])) {
        $this->caching = $vals['caching'];
      }
      if (isset($vals['maxVersions'])) {
        $this->maxVersions = $vals['maxVersions'];
      }
      if (isset($vals['timeRange'])) {
        $this->timeRange = $vals['timeRange'];
      }
      if (isset($vals['filterString'])) {
        $this->filterString = $vals['filterString'];
      }
      if (isset($vals['batchSize'])) {
        $this->batchSize = $vals['batchSize'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['authorizations'])) {
        $this->authorizations = $vals['authorizations'];
      }
      if (isset($vals['reversed'])) {
        $this->reversed = $vals['reversed'];
      }
    }
  }

  public function getName() {
    return 'TScan';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size94 = 0;
            $_etype97 = 0;
            $xfer += $input->readListBegin($_etype97, $_size94);
            for ($_i98 = 0; $_i98 < $_size94; ++$_i98)
            {
              $elem99 = null;
              $elem99 = new TColumn();
              $xfer += $elem99->read($input);
              $this->columns []= $elem99;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->caching);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->maxVersions);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->timeRange = new TTimeRange();
            $xfer += $this->timeRange->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filterString);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->batchSize);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::MAP) {
            $this->attributes = array();
            $_size100 = 0;
            $_ktype101 = 0;
            $_vtype102 = 0;
            $xfer += $input->readMapBegin($_ktype101, $_vtype102, $_size100);
            for ($_i104 = 0; $_i104 < $_size100; ++$_i104)
            {
              $key105 = '';
              $val106 = '';
              $xfer += $input->readString($key105);
              $xfer += $input->readString($val106);
              $this->attributes[$key105] = $val106;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->authorizations = new TAuthorization();
            $xfer += $this->authorizations->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->reversed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TScan');
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 1);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 2);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->columns));
        {
          foreach ($this->columns as $iter107)
          {
            $xfer += $iter107->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->caching !== null) {
      $xfer += $output->writeFieldBegin('caching', TType::I32, 4);
      $xfer += $output->writeI32($this->caching);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxVersions !== null) {
      $xfer += $output->writeFieldBegin('maxVersions', TType::I32, 5);
      $xfer += $output->writeI32($this->maxVersions);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timeRange !== null) {
      if (!is_object($this->timeRange)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('timeRange', TType::STRUCT, 6);
      $xfer += $this->timeRange->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filterString !== null) {
      $xfer += $output->writeFieldBegin('filterString', TType::STRING, 7);
      $xfer += $output->writeString($this->filterString);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->batchSize !== null) {
      $xfer += $output->writeFieldBegin('batchSize', TType::I32, 8);
      $xfer += $output->writeI32($this->batchSize);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_array($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::MAP, 9);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->attributes));
        {
          foreach ($this->attributes as $kiter108 => $viter109)
          {
            $xfer += $output->writeString($kiter108);
            $xfer += $output->writeString($viter109);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->authorizations !== null) {
      if (!is_object($this->authorizations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('authorizations', TType::STRUCT, 10);
      $xfer += $this->authorizations->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->reversed !== null) {
      $xfer += $output->writeFieldBegin('reversed', TType::BOOL, 11);
      $xfer += $output->writeBool($this->reversed);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Atomic mutation for the specified row. It can be either Put or Delete.
 */
class TMutation {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'put',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TPut',
      ),
    2 => array(
      'var' => 'deleteSingle',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\TDelete',
      ),
    );

  /**
   * @var TPut
   */
  public $put = null;
  /**
   * @var TDelete
   */
  public $deleteSingle = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['put'])) {
        $this->put = $vals['put'];
      }
      if (isset($vals['deleteSingle'])) {
        $this->deleteSingle = $vals['deleteSingle'];
      }
    }
  }

  public function getName() {
    return 'TMutation';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->put = new TPut();
            $xfer += $this->put->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->deleteSingle = new TDelete();
            $xfer += $this->deleteSingle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TMutation');
    if ($this->put !== null) {
      if (!is_object($this->put)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('put', TType::STRUCT, 1);
      $xfer += $this->put->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteSingle !== null) {
      if (!is_object($this->deleteSingle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('deleteSingle', TType::STRUCT, 2);
      $xfer += $this->deleteSingle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * A TRowMutations object is used to apply a number of Mutations to a single row.
 */
class TRowMutations {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'row',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'mutations',
      'isRequired' => true,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\TMutation',
        ),
      ),
    );

  /**
   * @var string
   */
  public $row = null;
  /**
   * @var TMutation[]
   */
  public $mutations = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['mutations'])) {
        $this->mutations = $vals['mutations'];
      }
    }
  }

  public function getName() {
    return 'TRowMutations';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->mutations = array();
            $_size110 = 0;
            $_etype113 = 0;
            $xfer += $input->readListBegin($_etype113, $_size110);
            for ($_i114 = 0; $_i114 < $_size110; ++$_i114)
            {
              $elem115 = null;
              $elem115 = new TMutation();
              $xfer += $elem115->read($input);
              $this->mutations []= $elem115;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TRowMutations');
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mutations !== null) {
      if (!is_array($this->mutations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('mutations', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->mutations));
        {
          foreach ($this->mutations as $iter116)
          {
            $xfer += $iter116->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THRegionInfo {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'regionId',
      'isRequired' => true,
      'type' => TType::I64,
      ),
    2 => array(
      'var' => 'tableName',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'startKey',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'endKey',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    5 => array(
      'var' => 'offline',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    6 => array(
      'var' => 'split',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    7 => array(
      'var' => 'replicaId',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    );

  /**
   * @var int
   */
  public $regionId = null;
  /**
   * @var string
   */
  public $tableName = null;
  /**
   * @var string
   */
  public $startKey = null;
  /**
   * @var string
   */
  public $endKey = null;
  /**
   * @var bool
   */
  public $offline = null;
  /**
   * @var bool
   */
  public $split = null;
  /**
   * @var int
   */
  public $replicaId = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['regionId'])) {
        $this->regionId = $vals['regionId'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startKey'])) {
        $this->startKey = $vals['startKey'];
      }
      if (isset($vals['endKey'])) {
        $this->endKey = $vals['endKey'];
      }
      if (isset($vals['offline'])) {
        $this->offline = $vals['offline'];
      }
      if (isset($vals['split'])) {
        $this->split = $vals['split'];
      }
      if (isset($vals['replicaId'])) {
        $this->replicaId = $vals['replicaId'];
      }
    }
  }

  public function getName() {
    return 'THRegionInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->regionId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->endKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->offline);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->split);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->replicaId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THRegionInfo');
    if ($this->regionId !== null) {
      $xfer += $output->writeFieldBegin('regionId', TType::I64, 1);
      $xfer += $output->writeI64($this->regionId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 2);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startKey !== null) {
      $xfer += $output->writeFieldBegin('startKey', TType::STRING, 3);
      $xfer += $output->writeString($this->startKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->endKey !== null) {
      $xfer += $output->writeFieldBegin('endKey', TType::STRING, 4);
      $xfer += $output->writeString($this->endKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->offline !== null) {
      $xfer += $output->writeFieldBegin('offline', TType::BOOL, 5);
      $xfer += $output->writeBool($this->offline);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->split !== null) {
      $xfer += $output->writeFieldBegin('split', TType::BOOL, 6);
      $xfer += $output->writeBool($this->split);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->replicaId !== null) {
      $xfer += $output->writeFieldBegin('replicaId', TType::I32, 7);
      $xfer += $output->writeI32($this->replicaId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TServerName {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'hostName',
      'isRequired' => true,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'port',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    3 => array(
      'var' => 'startCode',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    );

  /**
   * @var string
   */
  public $hostName = null;
  /**
   * @var int
   */
  public $port = null;
  /**
   * @var int
   */
  public $startCode = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['hostName'])) {
        $this->hostName = $vals['hostName'];
      }
      if (isset($vals['port'])) {
        $this->port = $vals['port'];
      }
      if (isset($vals['startCode'])) {
        $this->startCode = $vals['startCode'];
      }
    }
  }

  public function getName() {
    return 'TServerName';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hostName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->port);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->startCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TServerName');
    if ($this->hostName !== null) {
      $xfer += $output->writeFieldBegin('hostName', TType::STRING, 1);
      $xfer += $output->writeString($this->hostName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->port !== null) {
      $xfer += $output->writeFieldBegin('port', TType::I32, 2);
      $xfer += $output->writeI32($this->port);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startCode !== null) {
      $xfer += $output->writeFieldBegin('startCode', TType::I64, 3);
      $xfer += $output->writeI64($this->startCode);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THRegionLocation {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'serverName',
      'isRequired' => true,
      'type' => TType::STRUCT,
      'class' => '\TServerName',
      ),
    2 => array(
      'var' => 'regionInfo',
      'isRequired' => true,
      'type' => TType::STRUCT,
      'class' => '\THRegionInfo',
      ),
    );

  /**
   * @var TServerName
   */
  public $serverName = null;
  /**
   * @var THRegionInfo
   */
  public $regionInfo = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['serverName'])) {
        $this->serverName = $vals['serverName'];
      }
      if (isset($vals['regionInfo'])) {
        $this->regionInfo = $vals['regionInfo'];
      }
    }
  }

  public function getName() {
    return 'THRegionLocation';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->serverName = new TServerName();
            $xfer += $this->serverName->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->regionInfo = new THRegionInfo();
            $xfer += $this->regionInfo->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THRegionLocation');
    if ($this->serverName !== null) {
      if (!is_object($this->serverName)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('serverName', TType::STRUCT, 1);
      $xfer += $this->serverName->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->regionInfo !== null) {
      if (!is_object($this->regionInfo)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('regionInfo', TType::STRUCT, 2);
      $xfer += $this->regionInfo->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * A TIOError exception signals that an error occurred communicating
 * to the HBase master or a HBase region server. Also used to return
 * more general HBase error conditions.
 */
class TIOError extends TException {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'message',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'TIOError';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TIOError');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * A TIllegalArgument exception indicates an illegal or invalid
 * argument was passed into a procedure.
 */
class TIllegalArgument extends TException {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'message',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'TIllegalArgument';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TIllegalArgument');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


